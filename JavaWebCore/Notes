JavaWeb技术栈
B/S架构:浏览器/服务器  架构模式
->特点:客户端只需要浏览器,应用程序的逻辑和数据都存储在服务器端,浏览器只需要请求服务器获得Web资源,服务器把资源发送给浏览器即可
->优点:易于升级和维护
服务器端的资源分为动态资源和静态资源
静态资源:HTML,CSS,JavaScript等,负责页面展示
动态资源:Servlet,JSP等,负责逻辑处理(其实就是一些java代码,可以访问数据库,将访问到的有关数据交给静态资源去展示)
 浏览网页的具体过程:
     浏览器发送请求(遵循HTTP协议)->服务器对该请求进行解析(涉及到Tomcat等Web服务器)->动态资源访问数据库将数据取出交给静态资源->服务器响应
------------------------------------------------------------------------------------------------------------------------
HTTP协议特点:
1.基于TCP协议:面向连接,安全
2.基于请求-响应模型的:一次请求对应一次响应
3.HTTP协议对于事务处理没有记忆能力,每次请求,响应都是独立的
  缺点:多次请求间不能共享数据,解决方案:会话技术(cookie,session)
  优点:速度快

HTTP请求数据格式:
->请求行
->请求头
->请求体
   GET请求参数在请求行(第一行)中,没有请求体;POST请求参数在请求体里
------------------------------------------------------------------------------------------------------------------------
Web服务器
Web服务器是一个应用程序,对HTTP协议的操作进行封装,使得程序员不必直接对协议进行操作,让Web开发更加便捷.主要功能是提供网上信息浏览服务
------------------------------------------------------------------------------------------------------------------------
Tomcat部署项目
->将项目放置到webapps目录下,然后将war包放到webapps目录下,Tomcat会自动解压缩war文件
注意:Tomcat项目结构里index.jsp或index.html需要我们自己创建,作为默认初始页面
------------------------------------------------------------------------------------------------------------------------
Servlet
->是一门动态web资源开发技术,负责数据的逻辑处理
->实际是一个接口,我们需要定义它的实现类,由web服务器进行处理
   通俗来讲servlet专门用来接收客户端的请求，专门接收客户端的请求数据，然后调用底层service处理数据并生成结果
   程序员通过设置访问的url以及重写方法,让用户在网页里输入的东西可以按照程序员写的逻辑进行处理
   <1>客户端发送请求到服务器端
   <2>服务器将请求信息发送至Servlet
   <3>Servlet生成响应内容并将其传给服务器
   <4>服务器将响应返回给客户端

步骤:1.创建web项目,导入Servlet依赖坐标
    2.创建:定义一个类,实现Servlet接口,并重写接口中的所有方法,并在service方法中输入一句话
    3.配置:在类上使用@WebServlet注解,配置该Servlet的访问路径
    4.访问:启动Tomcat,浏览器输入URL访问该Servlet

->servlet对象和方法均由tomcat服务器创建和执行
->servlet在被访问时服务器会自动调用init方法和service方法进行初始化和服务

注意:在重写service方法里要对请求进行强转以及类型判断,如果每创建一个servlet实现类都要执行这些操作的话会特别繁琐,所以可以直接继承java为我们提供
的HttpServlet类,重写里面的doGet和doPost方法即可
------------------------------------------------------------------------------------------------------------------------
Servlet urlPattern配置

->Servlet想要被访问,必须配置其访问路径
1.一个Servlet,可以配置多个urlPattern
 @WebServlet(urlPatterns ={"/demo1","/demo2"})  //表示可以通过   demo1和demo2访问到该servlet
2.urlPattern配置规则
 1)精确匹配
 2)目录匹配
 3)扩展名匹配
 4)任意匹配
------------------------------------------------------------------------------------------------------------------------
Request(请求) & Response(响应)
->是servlet的service方法里面的参数
request其实是一个生成的对象,里面装着有关http的请求信息,程序员可以根据信息内容进行逻辑判断(例如密码校验)
response也是一个对象,里面装着http有关的响应信息
->request将接收到的请求信息内的键值对封装成了一个Map集合(泛型:Map<String,String[]>),并且为我们提供了getParameterMap()方法获取所有参数
  Map集合
------------------------------------------------------------------------------------------------------------------------
Request的请求转发
->是一种服务器内部资源跳转的方式(比如我在A号网站输入了信息,A号网站将该信息处理一部分后再交给B号网站处理)
Request为我们提供了req.getRequestDispatcher("需要转发的路径url").forward(req,resp)方法
请求转发之间应该数据共享,所以Request为我们提供了几个实现方法:
1.Void setAttribute(String name,Object o)存储数据到request域中(第一个参数是键,第二个是键值)
2.Object getAttribute(String name)根据键获取值
3.void removeAttribute(String name)删除对应键以及键值
------------------------------------------------------------------------------------------------------------------------
Response的重定向
->也是一种资源跳转的方式(A网站处理不了甩给B网站去做)
当浏览器请求的网站资源无法满足时会响应给服务器一个特殊状态码并且提供一个其他的路径(甩锅),浏览器接收后会跳转到该路径
实现方式:1.设置状态码:resp.getStatus(302)
        2.resp.setHeader("location","资源B路径url")
       简化方式:resp.sendRedirect("资源B路径url")
------------------------------------------------------------------------------------------------------------------------
重定向与请求转发的区别
1.重定向:  两次请求,一次响应; 搜索框内会改变url;  可以跳转到任意服务器位置;  资源不共享
2.请求转发:一次请求,一次响应; 搜索框url不发生改变; 只能跳转至服务器内的位置;  与转发的位置资源共享
------------------------------------------------------------------------------------------------------------------------
浏览器需要使用路径时需要加虚拟路径
服务器需要使用路径时不需要加虚拟目录
   获取动态虚拟路径的方式:String contextPath=request.getContextPath();
------------------------------------------------------------------------------------------------------------------------
Response设置响应字符
->通过获取输出流对响应体的内容进行操作
1.获取字符输出流
PrintWriter writer=response.getWriter()

2.在输出流里写入数据
writer.write("内容")
->如果想添加标题这种的话不能直接写</h1>内容</h1>,需要设置响应头
response.setContentType("text/html",charset=utf-8) //表示该请求头下面的请求体是html类型的,会用该类型的解析器来解析,并且使用的是utf-8的字符类型
->注意:流不需要关闭
------------------------------------------------------------------------------------------------------------------------
Response响应字节数据
ServletOutputStream outputStream=resp.getOutputStream()
outputStream.write(字节数据)
->IOUtils工具类使用
1.导入坐标(依赖)
 <dependency>
 <groupId>commons-io</groupId>
 <artifactId>commons-io</artifactId>
 <version>2.6</version>
 </dependency>
2.使用
 IOUtils.copy(输入流,输出流)
------------------------------------------------------------------------------------------------------------------------
                                     一个简单的登录注册系统的编写流程
                           需要用到的技术:1.Mybatis:用于操作数据库
                                        2.Tomcat:提供了一个服务器.解析请求头
                                        3.Servlet:在服务器内可以使用该接口使程序员可以对用户请求响应进行操作
                            其他相关技术:Maven,HTML等前端知识,数据库sql

 准备环境:1.创建数据库和用户信息表,并创建对应的实体类
         2.导入Mybatis坐标,MySQL驱动坐标(添加依赖)
         3.创建mybatis核心配置文件,UserMapper.xml映射文件,UserMapper接口

 大致流程:用户在登录页面中输入账号密码,点击提交后浏览器将信息封装成请求头发送给Tomcat服务器进行解析,我们使用Servlet接口重写doGet和doPost方法,
        在方法里先使用request.getParameter()方法获取请求体的账号密码信息,并编写好密码校验和注册的相关代码.在登录相关代码里,需要使用Mybatis
        查询数据库内是否存在该用户,随后通过返回值进行判断;在注册相关代码里,需要使用Mybatis查询数据库内是否存在该用户名,然后向数据库插入相关信息.
        随后通过PrintWriter的write方法编写响应头的内容

       浏览器:显示内容,将用户输入的账号密码打包成请求头发送给服务器
       服务器:使用的是Tomcat小型服务器,在服务器内使用Servlet接口实现密码校验以及注册
       数据库:使用的是MySQL数据库,用于存放用户的账号密码信息
------------------------------------------------------------------------------------------------------------------------
SqlSessionFactory代码优化
->问题:1.代码重复   2.工厂只创建一次,不要重复创建
解决思路:只让该代码执行一次---->静态代码块
步骤:1.创建工具类
    2.在类里将SqlSessionFactory用Private static修饰作为静态变量
    3.用static修饰静态代码块,块内写上创建工厂的代码(try-catch异常)
    4.创建静态getSqlSessionFactory方法,方法内返回SqlSessionFactory
   完成后,可以直接使用类名.getSqlSessionFactory即可


------------------------------------------------------------------------------------------------------------------------
JSP(JavaServer Pages)
->Java服务端页面:一种动态的网页技术,其中既可以定义HTML,JS,CSS等静态内容,还可以定义Java代码的动态内容
                                   JSP=HTML+Java
  作用:简化了Servlet开发里大量的HTML标签
  JSP 就是 Servlet，只是我们如果通过Servlet来拼接HTML代码太过于复杂，JSP能够大大的简化拼接HTML，因为它是以HTML代码为主，能够书写
  Java 代码。之所以要书写Java代码，是因为我们需要将业务处理的数据在HTML进行显示，而后台代码使用Java完成的，因此如果能够直接用Java那
  就简单了。
                                 该技术逐渐退出了历史舞台
------------------------------------------------------------------------------------------------------------------------
MVC模式(Model模型 View视图 Controller控制器)
->一种分层开发的模式(规范)
浏览器发送请求到控制器(Servlet),控制器从模型(Javabean类)中获取数据,再将数据发送给视图(JSP)进行展示

联系:表现层=控制器+视图      业务逻辑层+数据访问层=模型

注意:MVC仅仅是表现层的设计模式,与其他两层架构没有关系
三层架构
->表现层:接收请求,封装数据,调用业务逻辑层,响应数据(包含控制器和视图)//一般命名为com.zezai.controller
->业务层:对业务逻辑进行封装,组合数据访问层层中基本功能,形成复杂的业务逻辑//一般命名为com.zezai.service
->持久层:对数据库的CRUD基本操作(JDBC,Mybatis等)//一般命名为com.zezai.mapper/dao
------------------------------------------------------------------------------------------------------------------------
                                         会话技术
会话:用户的打开浏览器,访问Web资源,会话建立,直到有一方断开连接,会话结束.在一次会话中可以包含多次请求和响应
会话跟踪:一种维护浏览器状态的方法,服务器需要识别多次请求是否来自于同一浏览器,以便在同一次会话的多次请求间共享数据
->产生原因:因为HTTP协议的无状态性,服务器无法识别请求是否来自一个浏览器
->实现方式:1.客户端会话跟踪技术:Cookie
          2.服务端会话跟踪技术:Session
------------------------------------------------------------------------------------------------------------------------
Cookie的基本使用
->Cookie:客户端会话技术,将数据保存到客户端,以后每次请求都携带Cookie数据进行访问
1.在对应的Servlet的doGet方法里创建Cookie对象,设置数据
  Cookie cookie=new Cookie("key","value");
2.发送Cookie到客户端,使用response对象
  response.add(cookie);
原理:当第一次请求A服务器资源,服务器会根据你输入的信息,将它们放在响应头(cookie)里返回给浏览器
    当第二次请求B服务器资源时,服务器会将存储好的信息放在请求头(set-cookie)内对服务器进行访问

cookie生命周期:默认情况下,cookie存储在浏览器内存中,浏览器关闭,内存释放cookie消失
             通过setMaxAge(时间)可以设置cookie存活时间
               ->正数:将数据写进浏览器所在的电脑硬盘,到时间自动销毁
               ->负数:默认
               ->零:立马销毁
------------------------------------------------------------------------------------------------------------------------
Session的基本使用
->Session:提供的接口,将数据保存在服务端
1.获取Session对象
HttpSession session=request.getSession()
2.使用方法
->void setAttribute(String name,Object o):存储数据到session域中
->Object getAttribute(String name):根据Key获取值
->void removeAttribute(String name):根据Key删除值
原理:当一个浏览器多次请求服务器后都会创建Session对象,但是这个Session都是同一个,然后会将Session的序列号当做Cookie响应头发送给浏览器,当再有浏览器请求时,会将该
    Cookie作为请求头发送给服务器

Session在服务器关闭后会消失吗?
答:在正常关闭服务器的情况下,服务器会自动将Session写入硬盘的文件中(钝化),当再次启动服务器后,从文件中加载数据到Session中(活化)

在默认情况下,无操作,30分钟自动销毁,可以通过调用Session对象的invalidate()方法直接销毁
------------------------------------------------------------------------------------------------------------------------
Filter
概念:过滤器,是javaWeb三大组件之一(Servlet,Filter,Listener)之一
过滤器可以把对资源的请求拦截下来,从而实现一些特殊的功能(权限控制,统一编码处理,敏感字符处理)
1.定义类,实现Filter接口,并重写其所有方法
2.配置Filter拦截资源路径:在类上定义@WebFilter注解
3.在doFilter方法中写入需要执行的代码,再放行:filterChain.doFilter(servletRequest,servletResponse)

流程:执行放行前逻辑->放行->访问资源->执行放行后逻辑
注意:一般来说,放行前会对request进行处理,放行后会对response进行处理

Filter拦截路径配置
->具体资源:/index.jsp
->目录拦截:/user/*
->后缀名拦截:*.jsp
->拦截所有:/*

过滤器链:一个Web应用可以拥有多个过滤器同时存在(浏览器->过滤器1->过滤器2->web资源)
------------------------------------------------------------------------------------------------------------------------
Listener
概念:监听器,可以监听就是在application,session,request三个对象创建,销毁或者往其中添加修改删除属性时自动执行的功能组件
步骤:定义接口实现类,并重写所有方法
------------------------------------------------------------------------------------------------------------------------
AJAX
概念:异步(SHR)的JavaScript和XML
作用:1.与服务器进行数据交换,通过AJAX可以给服务器发送请求,并获取服务器响应的数据(以前还需要将Servlet转发给JSP在浏览器进行响应)
    2.异步交互:在不用加载整个页面的情况下与服务器交换数据并进行局部更新的技术(如搜索联想)
------------------------------------------------------------------------------------------------------------------------
Axios
作用:简化AJAX开发
------------------------------------------------------------------------------------------------------------------------
JSON
作用:由于语法简单,层次机构鲜明,现多用于浏览器与服务器之间的数据传输载体
优点:相比于用输入输出流response.getWriter().write进行传输,效率更高,易于阅读
使用方法:在HTML的Script标签里,定义json,并在json里定义属性以及它的值,然后通过alert(json.属性名)的方法直接获取到对应的值

JSON数据和Java对象进行转换
原因:无论是从浏览器传来的数据还是从服务器传回的数据,他们的数据对象格式是不同的,所以要进行转换
转换前的准备工作:导入阿里巴巴的Fastjson坐标

->请求数据:JSON字符串转为Java对象   User user=JSON.parseObject(jsonStr,User.class);
->响应数据:Java对象转为JSON字符串   String jsonStr=JSON.toJSONString(obj);

注意:request.getParameter()无法接收JSON格式的数据,需要通过request.getReader()->br.readLine()方式获取POST请求的请求体,然后再将获取的
    请求体进行转换
------------------------------------------------------------------------------------------------------------------------
Vue
概念:是一套前端框架,免除原来的JavaScript中的DOM操作(例如获取用户填写的表单数据这类操作document.getElementById),简化书写
->基于MVVM思想:当获取了来自JavaBean(模型)的数据后,页面可以根据数据的变化而产生相应的改变
步骤:1.在HTML页面里引入Vue.js文件
    2.在JS代码区域,创建Vue核心对象,进行数据绑定
    3.编写视图
------------------------------------------------------------------------------------------------------------------------
Element
概念:为网页设计提供了许多的组件,在官网可以获取
步骤:1.引入Element的css,js文件和Vue.js文件
    2.创建Vue的核心对象
    3.在div里直接复制粘贴官网代码即可(div里放el相关代码,style样式放在head标签里,script标签放在最后的Vue里)